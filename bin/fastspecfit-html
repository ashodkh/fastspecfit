#!/usr/bin/env python
"""Wrapper to build HTML output from previously generated QA files.

fastspecfit-html --fastspecfile ./fastspect.fits

fastspecfit-html --fastphotfile /global/cfs/cdirs/desi/spectro/fastspecfit/denali/tiles/merged/fastphot-denali-cumulative.fits \
  --fastspecfile /global/cfs/cdirs/desi/spectro/fastspecfit/denali/tiles/merged/fastspec-denali-cumulative.fits

"""
import pdb # for debugging
import os, sys, time
import numpy as np

from desiutil.log import get_logger
log = get_logger()

cfsroot = '/global/cfs/cdirs/'
httpsroot = 'https://data.desi.lbl.gov/'

def parse(options=None):
    """Parse input arguments.

    """
    import sys, argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--specprod', type=str, default='everest', choices=['denali', 'cascades', 'daily'],
                        help='Spectroscopic production to process.')
    #parser.add_argument('--coadd-type', type=str, default='cumulative', choices=['cumulative', 'pernight', 'perexp'],
    #                    help='Type of spectral coadds corresponding to the input zbestfiles.')
    parser.add_argument('--tile', default=None, type=str, nargs='*', help='Tile(s) to process.')
    parser.add_argument('--night', default=None, type=str, nargs='*', help='Night(s) to process (ignored if coadd-type is cumulative).')
    
    parser.add_argument('--targetids', type=str, default=None, help='Comma-separated list of target IDs to process.')
    parser.add_argument('-n', '--ntargets', type=int, help='Number of targets to process in each file.')
    parser.add_argument('--firsttarget', type=int, default=0, help='Index of first object to to process in each file (0-indexed).')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')

    parser.add_argument('--htmlhome', type=str, default='index.html', help='Main HTML page name.')
    parser.add_argument('--htmldir', type=str, help='Output directory for HTML files.')

    parser.add_argument('--outprefix', default=None, type=str, help='Optional prefix for output filename.')
    parser.add_argument('-o', '--outdir', default='.', type=str, help='Full path to desired output directory.')

    parser.add_argument('--fastphotfile', default=None, type=str, help='Full path to fastphot fitting results.')
    parser.add_argument('--fastspecfile', default=None, type=str, help='Full path to fastphot fitting results.')
    
    if options is None:
        args = parser.parse_args()
        log.info(' '.join(sys.argv))
    else:
        args = parser.parse_args(options)
        log.info('fastspecfit-html {}'.format(' '.join(options)))

    return args

def main(args=None, comm=None):
    """Make the HTML pages.

    """
    from astropy.table import Table
    from fastspecfit.io import read_fastspecfit
    
    if isinstance(args, (list, tuple, type(None))):
        args = parse(args)

    if args.htmldir is None:
        htmldir = os.path.join(os.getenv('FASTSPECFIT_HTML'), args.specprod)
    else:
        htmldir = args.htmldir
    if not os.path.isdir(htmldir):
        os.makedirs(htmldir, exist_ok=True)

    # Read the fitting results and get all the unique targetids.
    if (args.fastphotfile is None and args.fastspecfile is None):
        log.warning('Must provide one of --fastphotfile or --fastspecfile.')
        return
    
    elif (args.fastphotfile is not None and args.fastspecfile is not None):
        fastspec, metaspec, specprod, coadd_type = read_fastspecfit(args.fastspecfile)
        fastphot, metaphot, _specprod, _coadd_type = read_fastspecfit(args.fastphotfile, fastphot=True)
        if (specprod != _specprod) or (coadd_type != _coadd_type):
            log.warning('Mis-matching specprod or coadd_type in fastspec vs fastphot fitting results!')
            return

        from astropy.table import join
        fastspec['TILEID'] = metaspec['TILEID']
        fastphot['TILEID'] = metaphot['TILEID']

        joinkeys = ['TARGETID', 'TILEID']
        if 'NIGHT' in fastspec.colnames:
            joinkeys += 'NIGHT'
            fastspec['NIGHT'] = metaspec['NIGHT']
            fastphot['NIGHT'] = metaphot['NIGHT']
            
        fastfit = join(fastspec, fastphot, keys=joinkeys, join_type='outer',
                       table_names=['SPEC', 'PHOT'])
        metadata = join(metaspec, metaphot, keys=joinkeys, join_type='outer',
                       table_names=['SPEC', 'PHOT'])
        assert(np.all(fastfit['TARGETID'] == metadata['TARGETID']))
        assert(np.all(fastfit['TILEID'] == metadata['TILEID']))

    elif args.fastphotfile is None and args.fastspecfile is not None:
        fastfit, metadata, specprod, coadd_type = read_fastspecfit(args.fastspecfile)
        
    elif args.fastphotfile is not None and args.fastspecfile is None:
        fastfit, metadata, specprod, coadd_type = read_fastspecfit(args.fastphotfile, fastphot=True)

    else:
        pass # should never get here

    # optionally trim to a particular tile and/or night
    def _select_tiles_nights_targets(fastfit, metadata, tiles=None, nights=None):
        if fastfit is None or metadata is None:
            return fastfit, metadata
        keep = np.ones(len(fastfit), bool)
        if tiles:
            tilekeep = np.zeros(len(fastfit), bool)
            for tile in tiles:
                tilekeep = np.logical_or(tilekeep, metadata['TILEID'].astype(str) == tile)
            keep = np.logical_and(keep, tilekeep)
            log.info('Keeping {} objects from tile(s) {}'.format(len(fastfit), ','.join(tiles)))
        if nights and 'NIGHT' in metadata:
            nightkeep = np.zeros(len(fastfit), bool)
            for night in nights:
                nightkeep = np.logical_or(nightkeep, metadata['NIGHT'].astype(str) == night)
            keep = np.logical_and(keep, nightkeep)
            log.info('Keeping {} objects from night(s) {}'.format(len(fastfit), ','.join(nights)))
        return fastfit[keep], metadata[keep]
    
    fastfit, metadata = _select_tiles_nights_targets(
        fastfit, metadata, tiles=args.tile, nights=args.night)

    # parse the targetids optional input
    if args.targetids:
        targetids = [int(x) for x in args.targetids.split(',')]

        keep = np.where(np.isin(fastfit['TARGETID'], targetids))[0]
        if len(keep) == 0:
            log.warning('No matching targetids found!')
            return
        fastfit = fastfit[keep]
        metadata = metadata[keep]

    if args.ntargets is not None:
        keep = np.arange(args.ntargets) + args.firsttarget
        log.info('Keeping {} targets.'.format(args.ntargets))
        fastfit = fastfit[keep]
        metadata = metadata[keep]

    # read the tile info file for this production
    tilefile = os.path.join(os.getenv('DESI_SPECTRO_REDUX'), specprod, 'tiles-{}.csv'.format(specprod))
    tileinfo = Table.read(tilefile)
    tileinfo = tileinfo[np.isin(tileinfo['TILEID'], np.unique(metadata['TILEID']))]

    #log.info('Fix SURVEY for tiles 80605-80610, which are incorrectly identified as cmx tiles.')    
    #surveyfix = np.where((tileinfo['TILEID'] >= 80605) * (tileinfo['TILEID'] <= 80610))[0]
    #if len(surveyfix) > 0:
    #    tileinfo['SURVEY'][surveyfix] = 'sv1'
    log.info('Read survey info for {} tiles'.format(len(tileinfo)))

    t0 = time.time()

    # Build the home (index.html) page (always, irrespective of clobber)--
    build_htmlhome(htmldir, fastfit, metadata, tileinfo, htmlhome=args.htmlhome,
                   specprod=specprod)

    ## Now the individual pages.
    #htmltargetids = [specfile.replace(cfsroot, httpsroot).replace('.png', '.html') for specfile in fastspecfiles]
    #
    #nexttargetids = np.roll(np.atleast_1d(targetids), -1)
    #prevtargetids = np.roll(np.atleast_1d(targetids), 1)
    #nexthtmltargetids = np.roll(np.atleast_1d(htmltargetids), -1)
    #prevhtmltargetids = np.roll(np.atleast_1d(htmltargetids), 1)
    #
    #htmlargs = []
    #for ii, (targetid, htmltargetid, specfile, nexttargetid, prevtargetid, nexthtmltargetid, prevhtmltargetid) in enumerate(
    #        zip(targetids, htmltargetids, fastspecfiles, nexttargetids, prevtargetids, nexthtmltargetids, prevhtmltargetids)):
    #    htmlargs.append([ii, targetid, htmltargetid, specfile, nexttargetid, prevtargetid, nexthtmltargetid, prevhtmltargetid])
    #
    #if args.mp > 1:
    #    import multiprocessing
    #    with multiprocessing.Pool(args.mp) as P:
    #        P.map(_build_htmlpage_one, htmlargs)
    #else:
    #    [build_htmlpage_one(*_htmlargs) for _htmlargs in htmlargs]

    log.info('QA for everything took: {:.2f} sec'.format(time.time()-t0))

if __name__ == '__main__':
    main()
    
