#!/usr/bin/env python
"""Build spectroscopic templates.

"""
import pdb # for debugging
import os, sys, time
import numpy as np
import fitsio

from astropy.table import Table, Column
from fastspecfit.util import C_LIGHT

from desiutil.log import get_logger
log = get_logger()

templatedir = os.path.join(os.getenv('DESI_ROOT'), 'users', 'ioannis', 'desi-templates')

def read_tileinfo(targetclass='lrg', remove_vi=False, efftime_min=None,
                  specprod='denali'):
    """Optionally remove tiles which are being visually inspected.
     /global/cfs/cdirs/desi/sv/vi/TruthTables/Blanc/

    """
    vi = {'lrg': [80605, 80609],
          'elg': [80606, 80608, 86010],
          'bgs': [80613]}
    
    reduxdir = os.path.join(os.getenv('DESI_ROOT'), 'spectro', 'redux', specprod)
    tileinfo = Table.read(os.path.join(reduxdir, 'tiles-{}.csv'.format(specprod)))
    tileinfo = tileinfo[tileinfo['SURVEY'] != 'unknown']
    tileinfo = tileinfo[np.argsort(tileinfo['TILEID'])]
    
    if targetclass and remove_vi:
        rem = np.isin(tileinfo['TILEID'], vi[targetclass])
        log.info('Removing {} VI tiles.'.format(np.sum(rem)))
        tileinfo = tileinfo[np.logical_not(rem)]
        
    if efftime_min:
        rem = tileinfo['EFFTIME_SPEC']/60 <= efftime_min
        log.info('Removing {} tiles with efftime < {:.1f} min.'.format(
            np.sum(rem), efftime_min))
        tileinfo = tileinfo[np.logical_not(rem)]
    
    return tileinfo

def read_fastspecfit(tileinfo, specprod='denali', targetclass='lrg'):
    """Read the fastspecfit output for this production.

    """
    from desitarget.targets import main_cmx_or_sv

    fastspecdir = os.path.join(os.getenv('FASTSPECFIT_DATA'), specprod, 'tiles')
    specfile = os.path.join(fastspecdir, 'merged', 'fastspec-{}-cumulative.fits'.format(specprod))
    photfile = os.path.join(fastspecdir, 'merged', 'fastphot-{}-cumulative.fits'.format(specprod))

    spec = Table(fitsio.read(specfile, 'FASTSPEC'))
    meta = Table(fitsio.read(specfile, 'METADATA'))
    phot = Table(fitsio.read(photfile, 'FASTPHOT'))

    assert(np.all(spec['TARGETID'] == phot['TARGETID']))
    
    log.info('Read {} objects from {}'.format(len(spec), specfile))
    log.info('Read {} objects from {}'.format(len(phot), photfile))
    
    ontiles = np.where(np.isin(meta['TILEID'], tileinfo['TILEID']))[0]
    spec = spec[ontiles]
    meta = meta[ontiles]
    phot = phot[ontiles]
    
    log.info('Keeping {} objects on {}/{} unique tiles.'.format(
        len(ontiles), len(np.unique(meta['TILEID'])), len(tileinfo)))
    
    ngal = len(spec)
    
    # convenience magnitudes and targeting variables
    for band in ('G', 'R', 'Z', 'W1'):
        phot['{}MAG'.format(band)] = np.zeros(ngal, 'f4')
        good = np.where(meta['FLUX_{}'.format(band)] > 0)[0]
        phot['{}MAG'.format(band)][good] = 22.5 - 2.5 * np.log10(meta['FLUX_{}'.format(band)][good])
        
    for band in ('G', 'R', 'Z'):
        phot['{}FIBERMAG'.format(band)] = np.zeros(ngal, 'f4')
        good = np.where(meta['FIBERFLUX_{}'.format(band)] > 0)[0]
        phot['{}FIBERMAG'.format(band)][good] = 22.5 - 2.5 * np.log10(meta['FIBERFLUX_{}'.format(band)][good])

    targs = ['BGS_ANY', 'ELG', 'LRG', 'QSO']
    targcols = ['BGS', 'ELG', 'LRG', 'QSO']
    for targcol in targcols:
        spec[targcol] = np.zeros(ngal, bool)
        phot[targcol] = np.zeros(ngal, bool)
        
    for tile in tileinfo['TILEID']:
        I = np.where(meta['TILEID'] == tile)[0]
        if len(I) == 0:
            continue

        (desicol, bgscol, mwscol), (desimask, bgsmask, mwsmask), survey = main_cmx_or_sv(meta[I])

        for targcol, targ in zip(targcols, targs):
            phot[targcol][I] = meta[desicol][I] & desimask.mask(targ) != 0
            spec[targcol][I] = meta[desicol][I] & desimask.mask(targ) != 0
            
    #for targcol in targcols:
    #    log.info('  {}: {}'.format(targcol, np.sum(phot[targcol])))

    itarg = phot[targetclass.upper().replace('BGS', 'BGS_ANY')]
    log.info('Keeping {} {} targets.'.format(np.sum(itarg), targetclass.upper()))

    phot = phot[itarg]
    spec = spec[itarg]
    meta = meta[itarg]
    
    return phot, spec, meta

def select_gals(phot, spec, meta, verbose=True,
                z_minmax=None, Mr_minmax=None, gi_minmax=None, 
                rW1_minmax=None, return_indices=False):
    """Apply some basic quality cuts to select LRGs. Then divide into bins of
    redshift, luminosity, and color.

    """
    igal = (
        #(meta['SPECTYPE'] == 'GALAXY') *
        (meta['DELTACHI2'] > 25) * 
        (meta['FLUX_G'] > 0) * 
        (meta['FLUX_R'] > 0) * 
        (meta['FLUX_Z'] > 0) * 
        (meta['FLUX_W1'] > 0) *
        (phot['CONTINUUM_CHI2'] < 20) *
        (np.abs(spec['CONTINUUM_SMOOTHCORR_B']) < 10) *
        (np.abs(spec['CONTINUUM_SMOOTHCORR_R']) < 10) *
        (np.abs(spec['CONTINUUM_SMOOTHCORR_Z']) < 10)
    )
    
    # optionally select sub-populations
    if z_minmax:
        igal *= (meta['Z'] > z_minmax[0]) * (meta['Z'] < z_minmax[1])
    else:
        igal *= (meta['Z'] > 0.1) * (meta['Z'] < 1.1)
        
    if Mr_minmax:
        igal *= (phot['ABSMAG_R'] > Mr_minmax[0]) * (phot['ABSMAG_R'] < Mr_minmax[1])
        
    if gi_minmax:
        gi = phot['ABSMAG_G'] - phot['ABSMAG_I']
        igal *= (gi > gi_minmax[0]) * (gi < gi_minmax[1])
        
    if rW1_minmax:
        rW1 = phot['ABSMAG_R'] - phot['ABSMAG_W1']
        igal *= (rW1 > rW1_minmax[0]) * (rW1 < rW1_minmax[1])

    igal = np.where(igal)[0]

    if return_indices:
        return igal
    else:
        return phot[igal], spec[igal], meta[igal]

def stacking_bins(verbose=False):

    # define the stacking limits and the number of bin *centers*
    zlim, nz = [0.1, 1.1], 10
    Mrlim, nMr = [-24.5, -20], 5 #4
    gilim, ngi = [0.4, 1.4], 5 # 4
    rW1lim, nrW1 = [-1.0, 1.0], 5 # 2
    
    dz = (zlim[1] - zlim[0]) / nz
    dMr = (Mrlim[1] - Mrlim[0]) / nMr
    dgi = (gilim[1] - gilim[0]) / ngi
    drW1 = (rW1lim[1] - rW1lim[0]) / nrW1
    
    # build the array of (left) bin *edges*
    zgrid = np.arange(zlim[0], zlim[1], dz)
    Mrgrid = np.arange(Mrlim[0], Mrlim[1], dMr)
    gigrid = np.arange(gilim[0], gilim[1], dgi)
    rW1grid = np.arange(rW1lim[0], rW1lim[1], drW1)
    
    bins = {'z': {'min': zlim[0], 'max': zlim[1], 'del': dz, 'grid': zgrid},
            'Mr': {'min': Mrlim[0], 'max': Mrlim[1], 'del': dMr, 'grid': Mrgrid}, 
            'gi': {'min': gilim[0], 'max': gilim[1], 'del': dgi, 'grid': gigrid}, 
            'rW1': {'min': rW1lim[0], 'max': rW1lim[1], 'del': drW1, 'grid': rW1grid},
           }
    
    nbins = 1
    for key in bins.keys():
        nbins *= len(bins[key]['grid'])
        if verbose:
            log.debug(len(bins[key]['grid']))
    if verbose:
        log.debug(nbins)

    return bins, nbins

def spectra_in_bins(tileinfo, targetclass='lrg', specprod='denali', CFit=None, verbose=False):
    """Select objects in bins of rest-frame properties.
    
    """
    from astropy.table import Table, Column
    
    fastspecdir = os.path.join(os.getenv('FASTSPECFIT_DATA'), specprod, 'tiles')
    
    bins, nbins = stacking_bins()
    
    def sample_template():
        sample1 = Table()
        sample1.add_column(Column(name='tile', dtype=np.int32, length=1))
        sample1.add_column(Column(name='ibin', dtype=np.int32, length=1))
        sample1.add_column(Column(name='ngal', dtype=np.int32, length=1))
    
        sample1.add_column(Column(name='z', dtype='f4', length=1)) # mean bin center
        sample1.add_column(Column(name='zmin', dtype='f4', length=1))
        sample1.add_column(Column(name='zmax', dtype='f4', length=1))
    
        sample1.add_column(Column(name='Mr', dtype='f4', length=1))
        sample1.add_column(Column(name='Mrmin', dtype='f4', length=1))
        sample1.add_column(Column(name='Mrmax', dtype='f4', length=1))
    
        sample1.add_column(Column(name='gi', dtype='f4', length=1))
        sample1.add_column(Column(name='gimin', dtype='f4', length=1))
        sample1.add_column(Column(name='gimax', dtype='f4', length=1))

        sample1.add_column(Column(name='rW1', dtype='f4', length=1))
        sample1.add_column(Column(name='rW1min', dtype='f4', length=1))
        sample1.add_column(Column(name='rW1max', dtype='f4', length=1))
        return sample1
        
    samples, data = [], [] # these lists will be aligned

    dz = bins['z']['del']
    dMr = bins['Mr']['del']
    dgi = bins['gi']['del']
    drW1 = bins['rW1']['del']
    
    wave = None

    tiles = tileinfo['TILEID']
    for itile, tile in enumerate(tiles):
        if itile % 10 == 0:
            log.info('Working on tile {}/{}'.format(itile, len(tiles)))
        
        restfile = os.path.join(fastspecdir, 'deredshifted', '{}-{}-restflux.fits'.format(
            targetclass.lower(), tile))
        if not os.path.isfile(restfile): # not all of them exist
            continue

        # don't read the spectra if we're just counting
        allphot = Table(fitsio.read(restfile, ext='FASTPHOT'))
        allspec = Table(fitsio.read(restfile, ext='FASTSPEC'))
        allmeta = Table(fitsio.read(restfile, ext='METADATA'))
        flux = fitsio.read(restfile, ext='FLUX')
        ivar = fitsio.read(restfile, ext='IVAR')
        # the wavelength vector is identical, so just read one
        if wave is None:
            wave = fitsio.read(restfile, ext='WAVE')

        # select the sample of interest on this tile
        ibin = 0
        for zmin in bins['z']['grid']:
            for Mrmin in bins['Mr']['grid']:
                for gimin in bins['gi']['grid']:
                    for rW1min in bins['rW1']['grid']:
                        I = select_gals(allphot, allspec, allmeta, 
                                        z_minmax=[zmin, zmin+dz],
                                        Mr_minmax=[Mrmin, Mrmin+dMr],
                                        gi_minmax=[gimin, gimin+dgi],
                                        rW1_minmax=[rW1min, rW1min+drW1],
                                        verbose=False, return_indices=True)
                        nobj = len(I)
                        
                        if nobj > 10:
                            if verbose:
                                log.info('N={:04d}, z: {:.3f} {:.3f}, Mr: {:.2f} {:.2f}, g-i: {:.3f} {:.3f}, r-W1: {:.3f} {:.3f}'.format(
                                    len(I), zmin, zmin+dz, Mrmin, Mrmin+dMr, gimin, 
                                    gimin+dgi, rW1min, rW1min+drW1))
                                
                            _sample = sample_template()
                            _sample['tile'] = tile
                            _sample['ibin'] = ibin
                            _sample['ngal'] = len(I)
                            _sample['z'] = zmin + dz / 2
                            _sample['zmin'] = zmin
                            _sample['zmax'] = zmin + dz
                            _sample['Mr'] = Mrmin + dMr / 2
                            _sample['Mrmin'] = Mrmin
                            _sample['Mrmax'] = Mrmin + dMr
                            _sample['gi'] = gimin + dgi / 2
                            _sample['gimin'] = gimin
                            _sample['gimax'] = gimin + dgi
                            _sample['rW1'] = rW1min + drW1 / 2
                            _sample['rW1min'] = rW1min
                            _sample['rW1max'] = rW1min + drW1
                            samples.append(_sample)
                            
                            _data = {}
                            _data['flux'] = flux[I, :]
                            _data['ivar'] = ivar[I, :]
                            _data['fastphot'] = allphot[I]
                            _data['fastspec'] = allspec[I]
                            _data['metadata'] = allmeta[I]

                            # rebuild the best-fitting continuum model fits
                            if CFit is not None:
                                _data['cflux'] = []
                                for iobj in np.arange(nobj):
                                    cflux1, _ = CFit.SSP2data(
                                        CFit.sspflux, CFit.sspwave, 
                                        redshift=allmeta[I][iobj]['Z'],
                                        AV=allphot['CONTINUUM_AV'][I][iobj],
                                        coeff=allphot['CONTINUUM_COEFF'][I][iobj],# * CFit.massnorm,
                                        synthphot=False)
                                    _data['cflux'].append(cflux1)# * (1 + allmeta[I[iobj]]['Z']) # deredshift
                                _data['cflux'] = np.vstack(_data['cflux'])
                            data.append(_data)
                                
                        ibin += 1 # next bin

    # Stack the bin-level statistics table
    samples = Table(np.hstack(samples))
    data = np.array(data)

    # ...and now stack the data in each (unique) bin number.
    samplestack, sampledata = [], {}
    
    for ibin in sorted(set(samples['ibin'])):
        I = np.where(ibin == samples['ibin'])[0]
        _samplestack = samples[[I[0]]].copy()
        _samplestack.remove_column('tile')
        _samplestack['ngal'] = np.sum(samples[I]['ngal'])
        samplestack.append(_samplestack)

        _sampledata = {}
        _sampledata['flux'] = np.vstack([_data['flux'] for _data in data[I]])
        _sampledata['ivar'] = np.vstack([_data['ivar'] for _data in data[I]])
        _sampledata['fastphot'] = Table(np.hstack([_data['fastphot'] for _data in data[I]]))
        _sampledata['fastspec'] = Table(np.hstack([_data['fastspec'] for _data in data[I]]))
        _sampledata['metadata'] = Table(np.hstack([_data['metadata'] for _data in data[I]]))

        if CFit is not None:
            _sampledata['cflux'] = np.vstack([_data['cflux'] for _data in data[I]])
        
        sampledata.update({str(ibin): _sampledata})
        del _sampledata, _samplestack

    del data, samples
    samplestack = Table(np.hstack(samplestack))
    
    return samplestack, sampledata, wave

def parse(options=None):
    """Parse input arguments.

    """
    import sys, argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--specprod', type=str, default='denali', choices=['denali', 'cascades', 'daily'],
                        help='Spectroscopic production to process.')
    parser.add_argument('--targetclass', type=str, default='lrg', choices=['lrg', 'elg', 'bgs', 'qso'],
                        help='Target class to analyze.')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')

    parser.add_argument('--minwave', type=float, default=1200.0, help='Minimum output wavelength of stacked continuum spectra.')
    parser.add_argument('--maxwave', type=float, default=4e4, help='Maximum output wavelength of stacked continuum spectra.')

    parser.add_argument('-o', '--outdir', default=None, type=str, help='Full path to desired output directory.')
    parser.add_argument('--overwrite', action='store_true', help='Overwrite any existing output files.')
    
    if options is None:
        args = parser.parse_args()
        log.info(' '.join(sys.argv))
    else:
        args = parser.parse_args(options)
        log.info('fastspecfit-html {}'.format(' '.join(options)))

    return args

def main(args=None, comm=None):
    """Wrapper for building templates.

    """
    from fastspecfit.continuum import ContinuumFit
    from fastspecfit.templates.stack import stack_in_bins

    if isinstance(args, (list, tuple, type(None))):
        args = parse(args)

    log.info('Working on targetclass {}'.format(args.targetclass.upper()))

    # [1] Build the stacked spectra.
    stackfile = os.path.join(templatedir, '{}-stacks.fits'.format(args.targetclass))
    if not os.path.isfile(stackfile) or args.overwrite:
        log.info('Building stacked spectra in bins of properties.')
        
        # Read the master tile file and the fastspecfit fitting results.
        tileinfo = read_tileinfo(args.targetclass, remove_vi=True, efftime_min=5.0,
                                 specprod=args.specprod)
        allphot, allspec, allmeta = read_fastspecfit(tileinfo, targetclass=args.targetclass)

        # select the parent sample and specify the averaging bins
        bins, nbins = stacking_bins(verbose=True)
        galphot, galspec, galmeta = select_gals(allphot, allspec, allmeta)

        # intermediate QA
        from fastspecfit.templates.qa import qa_obs, qa_rest
        qa_obs(galphot, png=os.path.join(templatedir, 'qa', '{}-obs.png'.format(args.targetclass)))
        qa_rest(galphot, galspec, galmeta, bins=None, png=os.path.join(templatedir, 'qa', '{}-rest.png'.format(args.targetclass)))
        qa_rest(galphot, galspec, galmeta, bins=bins, png=os.path.join(templatedir, 'qa', '{}-rest-bins.png'.format(args.targetclass)))

        # select spectra in bins of properties, looping over all tiles
        CFit = ContinuumFit(minwave=args.minwave, maxwave=args.maxwave)
        sample, data, restwave = spectra_in_bins(tileinfo[5:8], targetclass=args.targetclass,
                                                 CFit=CFit, verbose=False)

        stack_in_bins(sample, data, restwave, continuumwave=CFit.sspwave, mp=args.mp, stackfile=stackfile)

    # [2] Model the stacked spectra and write out fitting results.
    log.info('Reading stacked spectra from {}'.format(stackfile))
    wave = fitsio.read(stackfile, ext='WAVE')
    flux = fitsio.read(stackfile, ext='FLUX')
    ivar = fitsio.read(stackfile, ext='IVAR')
    cwave = fitsio.read(stackfile, ext='CWAVE')
    cflux = fitsio.read(stackfile, ext='CFLUX')
    meta = fitsio.read(stackfile, ext='METADATA')

    ngal, npix = flux.shape

    from desispec.resolution import Resolution
    from scipy.sparse import identity

    from fastspecfit.continuum import ContinuumFit
    from fastspecfit.emlines import EMLineFit
    from fastspecfit.io import write_fastspecfit
    #from fastspecfit.io import DESISpectra, write_fastspecfit
    
    igal = 0
    good = np.where(ivar[igal, :] > 0)[0]
    npix = len(good)

    ztemp = 0.01

    data = {}
    data['zredrock'] = ztemp
    data['cameras'] = ['all']
    data['snr'] = [1.0]
    data['photsys'] = 'S'
    data['wave'] = [wave[good] * (1+ztemp)]
    data['flux'] = [flux[igal, good]]
    data['ivar'] = [ivar[igal, good]]
    data['linemask'] = [np.ones(npix, bool)]

    resolution_data = identity(n=npix)
    data['res'] = [Resolution(resolution_data)]
    
    minwave, maxwave = data['wave'][0].min()-3.0, data['wave'][0].max()+3.0

    CFit = ContinuumFit()
    EMFit = EMLineFit(minwave=minwave, maxwave=maxwave)
    #Spec = DESISpectra()

    cfit, continuummodel, smooth_continuum = CFit.continuum_specfit(data)    
    emfit = EMFit.fit(data, continuummodel, smooth_continuum, synthphot=False)

    fastmeta = Table()
    fastmeta.add_column(Column(name='TARGETID', data=np.ones(1, dtype=np.int32)))
    fastmeta.add_column(Column(name='TILEID', data=np.ones(1, dtype=np.int32)))
    fastmeta.add_column(Column(name='FIBER', data=np.ones(1, dtype=np.int32)))

    fastspec = Table()
    for col in cfit.colnames:
        fastspec[col] = cfit[col]
    for col in emfit.colnames:
        fastspec[col] = emfit[col]
        
    #fastspec, fastmeta = Spec.init_output(CFit=CFit, EMFit=EMFit)
    #for col in cfit.colnames:
    #    fastspec[col] = cfit[col]
    #for col in emfit.colnames:
    #    fastspec[col] = emfit[col]

    EMFit.qa_fastspec(data, fastspec[igal], fastmeta[igal], wavelims=(minwave, maxwave))
    
    pdb.set_trace()

if __name__ == '__main__':
    main()
    
