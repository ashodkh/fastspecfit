#!/usr/bin/env python
"""Stacking code.

fastspecfit-stack --fastspecfile ./fastspect.fits

fastspecfit-stack --fastphotfile /global/cfs/cdirs/desi/spectro/fastspecfit/denali/tiles/merged/fastphot-denali-cumulative.fits \
  --fastspecfile /global/cfs/cdirs/desi/spectro/fastspecfit/denali/tiles/merged/fastspec-denali-cumulative.fits

"""
import pdb # for debugging
import os, sys, time
import numpy as np

from fastspecfit.util import C_LIGHT

#from redrock.rebin import trapz_rebin
from desispec.interpolation import resample_flux
from desiutil.log import get_logger
log = get_logger()

def _deredshift_one(args):
    """Multiprocessing wrapper."""
    return deredshift_one(*args)

def deredshift_one(coaddwave, coaddflux, coaddivar, restwave, Iwave):
    """QA on one spectrum."""
    resampflux = np.zeros_like(restwave)
    resampivar = np.zeros_like(restwave)
    if len(Iwave) > 0:
        #resampflux[Iwave] = trapz_rebin(coaddwave, coaddflux, restwave[Iwave])
        flux, ivar = resample_flux(restwave[Iwave], coaddwave, coaddflux, ivar=coaddivar)
        resampflux[Iwave] = flux
        resampivar[Iwave] = ivar
    return resampflux, resampivar

def parse(options=None):
    """Parse input arguments.

    """
    import sys, argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--specprod', type=str, default='denali', choices=['denali', 'cascades', 'daily'],
                        help='Spectroscopic production to process.')
    parser.add_argument('--coadd-type', type=str, default='cumulative', choices=['cumulative', 'pernight', 'perexp'],
                        help='Type of spectral coadds corresponding to the input zbestfiles.')
    parser.add_argument('--tile', default=None, type=str, nargs='*', help='Tile(s) to process.')
    parser.add_argument('--night', default=None, type=str, nargs='*', help='Night(s) to process (ignored if coadd-type is cumulative).')
    
    parser.add_argument('--targetids', type=str, default=None, help='Comma-separated list of target IDs to process.')
    parser.add_argument('-n', '--ntargets', type=int, help='Number of targets to process in each file.')
    parser.add_argument('--firsttarget', type=int, default=0, help='Index of first object to to process in each file (0-indexed).')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')

    parser.add_argument('--htmlhome', type=str, default='index.html', help='Main HTML page name.')
    parser.add_argument('--htmldir', type=str, help='Output directory for HTML files.')

    parser.add_argument('--outprefix', default=None, type=str, help='Optional prefix for output filename.')
    parser.add_argument('-o', '--outdir', default='.', type=str, help='Full path to desired output directory.')

    parser.add_argument('--fastphotfile', default=None, type=str, help='Full path to fastphot fitting results.')
    parser.add_argument('--fastspecfile', default=None, type=str, help='Full path to fastphot fitting results.')
    
    if options is None:
        args = parser.parse_args()
        log.info(' '.join(sys.argv))
    else:
        args = parser.parse_args(options)
        log.info('fastspecfit-html {}'.format(' '.join(options)))

    return args

def main(args=None, comm=None):
    """Stack the spectra.

    """
    from astropy.table import Table
    from fastspecfit.continuum import ContinuumFit
    from fastspecfit.emlines import EMLineFit
    from fastspecfit.io import DESISpectra, read_fastspecfit
    
    if isinstance(args, (list, tuple, type(None))):
        args = parse(args)

    # Read the fitting results and get all the unique targetids.
    if (args.fastphotfile is None and args.fastspecfile is None):
        log.warning('Must provide one of --fastphotfile or --fastspecfile.')
        return
    
    elif (args.fastphotfile is not None and args.fastspecfile is not None):
        fastspec, metaspec, specprod, coadd_type = read_fastspecfit(args.fastspecfile)
        fastphot, metaphot, _specprod, _coadd_type = read_fastspecfit(args.fastphotfile, fastphot=True)
        if (specprod != _specprod) or (coadd_type != _coadd_type):
            log.warning('Mis-matching specprod or coadd_type in fastspec vs fastphot fitting results!')
            return

        from astropy.table import join
        # temporarily add TILEID to the tables so we can use it to join,
        # together with TARGETID and, optionally, NIGHT.
        joinkeys = ['TARGETID', 'TILEID']
        if 'NIGHT' in fastspec.colnames:
            joinkeys += 'NIGHT'
        fastspec['TILEID'] = metaspec['TILEID']
        fastphot['TILEID'] = metaphot['TILEID']
        
        fastfit = join(fastspec, fastphot, join_type='outer', table_names=['SPEC', 'PHOT'], keys=joinkeys)
        metadata = join(metaspec, metaphot, join_type='outer', table_names=['SPEC', 'PHOT'], keys=joinkeys)
        assert(np.all(fastfit['TARGETID'] == metadata['TARGETID']))
        assert(np.all(fastfit['TILEID'] == metadata['TILEID']))

    elif args.fastphotfile is None and args.fastspecfile is not None:
        fastfit, metadata, specprod, coadd_type = read_fastspecfit(args.fastspecfile)
        
    elif args.fastphotfile is not None and args.fastspecfile is None:
        fastfit, metadata, specprod, coadd_type = read_fastspecfit(args.fastphotfile, fastphot=True)

    else:
        pass # should never get here

    # optionally trim to a particular tile and/or night
    def _select_tiles_nights_targets(fastfit, metadata, tiles=None, nights=None):
        if fastfit is None or metadata is None:
            return fastfit, metadata
        keep = np.ones(len(fastfit), bool)
        if tiles:
            tilekeep = np.zeros(len(fastfit), bool)
            for tile in tiles:
                tilekeep = np.logical_or(tilekeep, metadata['TILEID'].astype(str) == tile)
            keep = np.logical_and(keep, tilekeep)
            log.info('Keeping {} objects from tile(s) {}'.format(len(fastfit), ','.join(tiles)))
        if nights and 'NIGHT' in metadata:
            nightkeep = np.zeros(len(fastfit), bool)
            for night in nights:
                nightkeep = np.logical_or(nightkeep, metadata['NIGHT'].astype(str) == night)
            keep = np.logical_and(keep, nightkeep)
            log.info('Keeping {} objects from night(s) {}'.format(len(fastfit), ','.join(nights)))
        return fastfit[keep], metadata[keep]
    
    fastfit, metadata = _select_tiles_nights_targets(
        fastfit, metadata, tiles=args.tile, nights=args.night)

    # parse the targetids optional input
    if args.targetids:
        targetids = [int(x) for x in args.targetids.split(',')]

        keep = np.where(np.isin(fastfit['TARGETID'], targetids))[0]
        if len(keep) == 0:
            log.warning('No matching targetids found!')
            return
        fastfit = fastfit[keep]
        metadata = metadata[keep]

    if args.ntargets is not None:
        keep = np.arange(args.ntargets) + args.firsttarget
        log.info('Keeping {} targets.'.format(args.ntargets))
        fastfit = fastfit[keep]
        metadata = metadata[keep]

    zbestdir = os.path.join(os.getenv('DESI_SPECTRO_REDUX'), specprod, 'tiles')

    if args.outdir:
        if not os.path.isdir(args.outdir):
            os.makedirs(args.outdir, exist_ok=True)
        
    # Initialize the continuum- and emission-line fitting classes.
    t0 = time.time()
    CFit = ContinuumFit()
    EMFit = EMLineFit()
    Spec = DESISpectra()
    log.info('Initializing the classes took: {:.2f} sec'.format(time.time()-t0))
    
    # read the tile info file for this production
    tilefile = os.path.join(os.getenv('DESI_SPECTRO_REDUX'), specprod, 'tiles-{}.csv'.format(specprod))
    tileinfo = Table.read(tilefile)
    tileinfo = tileinfo[np.isin(tileinfo['TILEID'], np.unique(metadata['TILEID']))]
    log.info('Read survey info for {} tiles'.format(len(tileinfo)))

    # rest-frame resampling parameters
    obswave_min, obswave_max = 3600.0, 9800.0
    zmax = {'ELG': 1.6, 'LRG': 1.3, 'QSO': 3.5, 'BGS_ANY': 0.7}

    pixkms = 25.0                            # pixel size [km/s]Traceback (most recent call last):
    dlogwave = pixkms / C_LIGHT / np.log(10) # pixel size [log-lambda]

    # For each unique tile, select targets of each class and build the
    # rest-frame spectra.
    targetclasses = ('ELG', 'LRG', 'QSO', 'BGS_ANY')#, 'MWS_ANY')

    for tinfo in tileinfo:
        tile = tinfo['TILEID']
        log.info('Working on tile {}'.format(tile))

        if tinfo['SURVEY'].upper() == 'SV1':
            from desitarget.sv1.sv1_targetmask import desi_mask#, bgs_mask, mws_mask
            desibit = 'SV1_DESI_TARGET'
            bgsbit = 'SV1_BGS_TARGET'
            mwsbit = 'SV1_MWS_TARGET'
        elif tinfo['SURVEY'].upper() == 'SV2':
            from desitarget.sv2.sv2_targetmask import desi_mask#, bgs_mask, mws_mask
            desibit = 'SV2_DESI_TARGET'
            bgsbit = 'SV2_BGS_TARGET'
            mwsbit = 'SV2_MWS_TARGET'
        else:
            NotImplementedError

        # need to account for the join suffix when we have both fastspec and
        # fastphot output
        if 'DESI_TARGET_SPEC' in metadata.colnames:
            desibit = desibit+'_SPEC'
            bgsbit = bgsbit+'_SPEC'
            mwsbit = mwsbit+'_SPEC'
            fibercol = 'FIBER_SPEC'
            thrunightcol = 'THRUNIGHT_SPEC'
        else:
            fibercol = 'FIBER'
            thrunightcol = 'THRUNIGHT'
            
        for targetclass in targetclasses:
            targintile = np.where(
                (metadata['Z_SPEC'] > 1.0) * # minimum redshift!
                (metadata['Z_SPEC'] < 1.1) * # minimum redshift!
                (tile == metadata['TILEID']) *
                metadata[desibit] & desi_mask.mask(targetclass) != 0)[0]
            if len(targintile) == 0:
                log.info('No good {} targets in tile {}...moving on.'.format(targetclass, tile))
                continue
            #targintile = targintile[:22]
            
            targ_fastfit = fastfit[targintile]
            targ_metadata = metadata[targintile]
            nobj = len(targ_metadata)

            # Construct the zbestfiles filenames based on the input (only
            # supports coadd_type=='cumulative').
            allpetals = targ_metadata[fibercol].data // 500
            thrunights = targ_metadata[thrunightcol].astype(str).data
            targetids = targ_metadata['TARGETID']
            assert(len(np.unique(thrunights)) == 1)

            zbestfiles = []
            for petal in set(allpetals):
                indx = np.where((petal == allpetals))[0]
                zbestfile = os.path.join(zbestdir, 'cumulative', str(tile), thrunights[indx[0]], 'zbest-{}-{}-thru{}.fits'.format(
                    petal, tile, thrunights[indx[0]]))
                zbestfiles.append(zbestfile)

            Spec.find_specfiles(zbestfiles=zbestfiles, specprod=specprod,
                                coadd_type='cumulative', targetids=targetids)
            #dataphot = Spec.read_and_unpack(CFit, fastphot=True, synthphot=False)
            dataspec = Spec.read_and_unpack(CFit, fastphot=False, synthphot=False,
                                            remember_coadd=True)
            assert(len(dataspec) == nobj)

            # now resample onto a constant log-lambda binning scale
            restwave = 10**np.arange(np.log10(obswave_min / (1+zmax[targetclass])), np.log10(obswave_max), dlogwave)
            restwave_min = np.min(restwave)
            restwave_max = np.max(restwave)
            npix = len(restwave)

            pad = 2 # [angstroms]
            mpargs = []
            for iobj in np.arange(nobj):
                oneplusz = 1 + dataspec[iobj]['zredrock']
                coaddwave = dataspec[iobj]['coadd_wave'] / oneplusz
                coaddflux = dataspec[iobj]['coadd_flux'] * oneplusz
                coaddivar = dataspec[iobj]['coadd_ivar'] / oneplusz**2
                Iwave = np.where((restwave > np.min(coaddwave+pad)) * (restwave < np.max(coaddwave-pad)))[0]
                mpargs.append((coaddwave, coaddflux, coaddivar, restwave, Iwave))
                
            t0 = time.time()
            if args.mp > 1:
                import multiprocessing
                with multiprocessing.Pool(args.mp) as P:
                    res = P.map(_deredshift_one, mpargs)
            else:
                res = [deredshift_one(*_mpargs) for _mpargs in mpargs]
                
            res = list(zip(*res))
            restflux = np.vstack(res[0]).astype('f4')
            restivar = np.vstack(res[1]).astype('f4')
            log.info('De-redshifting done in {:.2f} sec'.format(time.time()-t0))

            import matplotlib.pyplot as plt
            plt.plot(restwave, np.sum(restflux, axis=0)) ; plt.xlim(3000, 4200) ; plt.savefig('test.png')
            pdb.set_trace()

    log.info('QA for everything took: {:.2f} sec'.format(time.time()-t0))

if __name__ == '__main__':
    main()
    
