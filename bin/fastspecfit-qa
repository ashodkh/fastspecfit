#!/usr/bin/env python
"""fastspecfit QA

fastspecfit-qa --photfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/photfit-80607-20201214.fits --specfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/specfit-80607-20201214.fits --outdir /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/qa/80607 --night 20201214 --tile 80607 --mp 32 --ntargets 20 --firsttarget 50

fastspecfit-qa --photfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/photfit-80608-20201215.fits --specfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/specfit-80608-20201215.fits --outdir /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/qa/80608 --night 20201215 --tile 80608 --mp 32 --ntargets 20 --firsttarget 50

fastspecfit-qa --photfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/photfit-80613-20201221.fits --specfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/specfit-80613-20201221.fits --outdir /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/qa/80613 --night 20201221 --tile 80613 --mp 32 --ntargets 20 --firsttarget 50

fastspecfit-qa --photfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/photfit-80607-20201214.fits --specfitfile /global/cfs/cdirs/desi/users/ioannis/fastspecfit/blanc/tiles/specfit-80607-20201214.fits --outdir tmp/lrg --night 20201214 --tile 80607 --mp 32 --targetids 39633317678548005,39633317678549957,39633331544917404,39633321159819482

"""
import pdb # for debugging
import os, sys, time
import numpy as np

from desiutil.log import get_logger
log = get_logger()

# ridiculousness!
import tempfile
os.environ['MPLCONFIGDIR'] = tempfile.mkdtemp()

def _desiqa_one(args):
    """Multiprocessing wrapper."""
    return desiqa_one(*args)

def desiqa_one(CFit, EMFit, data=None, specfit=None, photfit=None, outdir=None, suffix=None):
    """QA on one spectrum."""
    #t0 = time.time()
    if photfit is not None:
        CFit.qa_photfit(photfit, specfit=specfit, suffix=suffix, outdir=outdir)
    if specfit is not None:
        EMFit.qa_specfit(data, specfit, suffix=suffix, outdir=outdir)
    #log.info('Building took {:.2f} sec'.format(time.time()-t0))

def parse(options=None):
    """Parse input arguments.

    """
    import sys, argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--tile', default=None, type=str, nargs='*', help='Generate QA for all objects on this tile.')
    parser.add_argument('--night', default=None, type=str, nargs='*', help='Generate QA for all objects observed on this night.')
    parser.add_argument('--targetids', type=str, default=None, help='Comma-separated list of target IDs to process.')
    parser.add_argument('-n', '--ntargets', type=int, help='Number of targets to process in each file.')
    parser.add_argument('--firsttarget', type=int, default=0, help='Index of first object to to process in each file (0-indexed).')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')

    parser.add_argument('--suffix', default=None, type=str, help='Optional suffix for output filename.')
    parser.add_argument('-o', '--outdir', default=None, type=str, help='Full path to desired output directory.')
    
    parser.add_argument('--photfitfile', default=None, type=str, help='Full path to photfit fitting results.')
    parser.add_argument('--specfitfile', default=None, type=str, help='Full path to photfit fitting results.')
    
    #parser.add_argument('fastspecfitfile', type=str, help='Full path to results FITS file written by fastspecfit.')

    if options is None:
        args = parser.parse_args()
        log.info(' '.join(sys.argv))
    else:
        args = parser.parse_args(options)
        log.info('fastspecfit-qa {}'.format(' '.join(options)))

    return args

def main(args=None, comm=None):
    """Main module.

    """
    import fitsio
    from astropy.table import Table
    from fastspecfit.continuum import ContinuumFit
    from fastspecfit.emlines import EMLineFit
    from fastspecfit.external.desi import DESISpectra

    if isinstance(args, (list, tuple, type(None))):
        args = parse(args)

    # Read the fitting results.
    if args.photfitfile is None and args.specfitfile is None:
        log.warning('Must provide one or both of --photfitfile and/or --specfitfile.')
        return

    def _check_and_read(filename):
        if filename:
            if os.path.isfile(filename):
                fastfit, hdr = fitsio.read(filename, header=True, ext='RESULTS')
                specprod = hdr['SPECPROD']
                fastfit = Table(fastfit)
                log.info('Read {} objects from {}'.format(len(fastfit), filename))
                return fastfit, specprod
            else:
                log.warning('File {} not found.'.format(filename))
                raise IOError
        else:
            return None, None

    specfit, specprod_spec = _check_and_read(args.specfitfile)
    photfit, specprod_phot = _check_and_read(args.photfitfile)
    if photfit is None and specfit is None:
        log.warning('Required input(s) --photfitfile and/or --specfitfile not provided!')
        return

    # parse the targetids optional input
    if args.targetids:
        targetids = [int(x) for x in args.targetids.split(',')]
    else:
        targetids = args.targetids

    # optionally trim to a particular tile and/or night
    def _select_tiles_nights_targets(fastfit, tiles=None, nights=None, targetids=None):
        if fastfit and (tiles or nights or targetids):
            keep = np.ones(len(fastfit), bool)
            if targetids:
                targetkeep = np.zeros(len(fastfit), bool)
                for targetid in targetids:
                    targetkeep = np.logical_or(targetkeep, fastfit['TARGETID'] == targetid)
                keep = np.logical_and(keep, targetkeep)
            if tiles:
                tilekeep = np.zeros(len(fastfit), bool)
                for tile in tiles:
                    tilekeep = np.logical_or(tilekeep, fastfit['TILEID'].astype(str) == tile)
                keep = np.logical_and(keep, tilekeep)
            if nights:
                nightkeep = np.zeros(len(fastfit), bool)
                for night in nights:
                    nightkeep = np.logical_or(nightkeep, fastfit['NIGHT'].astype(str) == night)
                keep = np.logical_and(keep, nightkeep)
            fastfit = fastfit[keep]
            #log.info('Keeping {} spectra from tile {} on night {}.'.format(len(fastfit), tile, night))
        return fastfit

    photfit = _select_tiles_nights_targets(photfit, tiles=args.tile, nights=args.night, targetids=targetids)
    specfit = _select_tiles_nights_targets(specfit, tiles=args.tile, nights=args.night, targetids=targetids)

    #if photfit is not None and specfit is not None:
    #    assert(specprod_phot == specprod_spec)
    #    specprod = specprod_spec
    #    fastfit = specfit
    #elif photfit is None and specfit is not None:
    #    specprod = specprod_spec
    #    fastfit = specfit
    #elif photfit is not None and specfit is None:
    #    specprod = specprod_phot
    #    fastfit = photfit
    #log.info('Found specprod={}'.format(specprod))

    # Initialize the continuum- and emission-line fitting classes.
    t0 = time.time()
    CFit = ContinuumFit()
    EMFit = EMLineFit()
    log.info('Initializing the classes took: {:.2f} sec'.format(time.time()-t0))

    if specfit:
        Spec = DESISpectra()
        
        # Get the spectra (if needed).
        Spec.find_specfiles(fastfit=specfit, specprod=specprod_spec, targetids=targetids,
                            firsttarget=args.firsttarget, ntargets=args.ntargets)
        if len(Spec.specfiles) == 0:
            return
        data = Spec.read_and_unpack(CFit, synthphot=False)
        refindx = np.array(['{}-{}-{}'.format(night, tile, tid) for night, tile, tid in zip(Spec.fibermap['FIRST_NIGHT'], Spec.fibermap['FIRST_TILEID'], Spec.fibermap['TARGETID'])])

        sindx = np.array(['{}-{}-{}'.format(night, tile, tid) for night, tile, tid in zip(specfit['NIGHT'], specfit['TILEID'], specfit['TARGETID'])])
        specfit = specfit[np.hstack([np.where(rindx == sindx)[0] for rindx in refindx])]
        
        #log.warning('Maybe sort by tile-night-targetid rather than expid???')
        #specfit = specfit[np.hstack([np.where(expid == specfit['EXPID'])[0] for expid in Spec.fibermap['EXPID']])]
        #assert(np.all(specfit['EXPID'] == Spec.fibermap['EXPID']))
        
        if photfit:
            pindx = np.array(['{}-{}-{}'.format(night, tile, tid) for night, tile, tid in zip(photfit['NIGHT'], photfit['TILEID'], photfit['TARGETID'])])
            photfit = photfit[np.hstack([np.where(rindx == pindx)[0] for rindx in refindx])]
            assert(np.all(specfit['TARGETID'] == photfit['TARGETID']))

        assert(np.all(specfit['TARGETID'] == Spec.zbest['TARGETID']))

        ## sort
        #
        #psrt = np.argsort(['{}-{}-{}'.format(night, tile, tid) for night, tile, tid in zip(photfit['NIGHT'], photfit['TILEID'], photfit['TARGETID'])])
        #specfit = specfit[ssrt]
        #photfit = photfit[psrt]
        #assert(np.all(photfit['TARGETID'] == specfit['TARGETID']))

    if args.outdir:
        if not os.path.isdir(args.outdir):
            os.makedirs(args.outdir)
        
    # Build the QA in parallel
    t0 = time.time()
    if photfit is not None and specfit is not None:
        qaargs = [(CFit, EMFit, data[igal], specfit[igal], photfit[igal], args.outdir, args.suffix)
                  for igal in np.arange(len(specfit))]
    elif photfit is None and specfit is not None:
        qaargs = [(CFit, EMFit, data[igal], specfit[igal], None, args.outdir, args.suffix)
                  for igal in np.arange(len(specfit))]
    elif photfit is not None and specfit is None:
        qaargs = [(CFit, EMFit, None, None, photfit[igal], args.outdir, args.suffix)
                  for igal in np.arange(len(photfit))]
    else:
        pass
        
    if args.mp > 1:
        import multiprocessing
        with multiprocessing.Pool(args.mp) as P:
            P.map(_desiqa_one, qaargs)
    else:
        [desiqa_one(*_qaargs) for _qaargs in qaargs]
    log.info('QA for everything took: {:.2f} sec'.format(time.time()-t0))

if __name__ == '__main__':
    main()
    
