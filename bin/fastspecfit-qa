#!/usr/bin/env python
"""fastspecfit QA

fastspecfit-qa --outdir . --fastspec /global/cfs/cdirs/desi/users/ioannis/fastspecfit/daily/tiles/fastspec-80607-80613-20201215-20201223.fits --fastphot /global/cfs/cdirs/desi/users/ioannis/fastspecfit/daily/tiles/fastphot-80607-80613-20201215-20201223.fits

"""
import pdb # for debugging
import os, sys, time
import numpy as np

from desiutil.log import get_logger
log = get_logger()

# ridiculousness!
import tempfile
os.environ['MPLCONFIGDIR'] = tempfile.mkdtemp()

def _desiqa_one(args):
    """Multiprocessing wrapper."""
    return desiqa_one(*args)

def desiqa_one(CFit, EMFit, data=None, fastspec=None, fastphot=None, outdir=None, suffix=None):
    """QA on one spectrum."""
    #t0 = time.time()
    if fastphot is not None:
        CFit.qa_fastphot(fastphot, fastspec=fastspec, suffix=suffix, outdir=outdir)
    if fastspec is not None:
        EMFit.qa_fastspec(data, fastspec, suffix=suffix, outdir=outdir)
    #log.info('Building took {:.2f} sec'.format(time.time()-t0))

def parse(options=None):
    """Parse input arguments.

    """
    import sys, argparse

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--tile', default=None, type=str, help='Generate QA for all objects on this tile.')
    parser.add_argument('--night', default=None, type=str, help='Generate QA for all objects observed on this night.')
    parser.add_argument('--targetids', type=str, default=None, help='Comma-separated list of target IDs to process.')
    parser.add_argument('-n', '--ntargets', type=int, help='Number of targets to process in each file.')
    parser.add_argument('--firsttarget', type=int, default=0, help='Index of first object to to process in each file (0-indexed).')
    parser.add_argument('--mp', type=int, default=1, help='Number of multiprocessing processes per MPI rank or node.')

    parser.add_argument('--suffix', default=None, type=str, help='Optional suffix for output filename.')
    parser.add_argument('-o', '--outdir', default=None, type=str, help='Full path to desired output directory.')
    
    parser.add_argument('--fastphotfile', default=None, type=str, help='Full path to fastphot fitting results.')
    parser.add_argument('--fastspecfile', default=None, type=str, help='Full path to fastphot fitting results.')
    parser.add_argument('zbestdata', nargs='*', help='Full path to zbest file(s) or a directory containing zbest file(s).')
    
    #parser.add_argument('fastspecfitfile', type=str, help='Full path to results FITS file written by fastspecfit.')

    if options is None:
        args = parser.parse_args()
        log.info(' '.join(sys.argv))
    else:
        args = parser.parse_args(options)
        log.info('fastspecfit-qa {}'.format(' '.join(options)))

    return args

def main(args=None, comm=None):
    """Main module.

    """
    import fitsio
    from astropy.table import Table
    from fastspecfit.continuum import ContinuumFit
    from fastspecfit.emlines import EMLineFit
    from fastspecfit.io import DESISpectra

    if isinstance(args, (list, tuple, type(None))):
        args = parse(args)

    # Read the fitting results.
    if args.fastphotfile is None and args.fastspecfile is None:
        log.warning('Must provide one or both of --fastphotfile and/or --fastspecfile.')
        return

    def _check_and_read(filename):
        if filename:
            if os.path.isfile(filename):
                fastfit, hdr = fitsio.read(filename, header=True, ext='RESULTS')
                specprod = hdr['SPECPROD']
                fastfit = Table(fastfit)
                log.info('Read {} objects from {}'.format(len(fastfit), filename))
                return fastfit, specprod
            else:
                log.warning('File {} not found.'.format(filename))
                raise IOError
        else:
            return None, None

    fastspec, specprod_spec = _check_and_read(args.fastspecfile)
    fastphot, specprod_phot = _check_and_read(args.fastphotfile)

    if fastphot is not None and fastspec is not None:
        assert(np.all(fastphot['TARGETID'] == fastspec['TARGETID']))
        assert(specprod_phot == specprod_spec)
        specprod = specprod_spec
        fastfit = fastspec
    elif fastphot is None and fastspec is not None:
        specprod = specprod_spec
        fastfit = fastspec
    elif fastphot is not None and fastspec is None:
        specprod = specprod_phot
        fastfit = fastphot
    else:
        log.warning('Required input(s) --fastphotfile and/or --fastspecfile not provided!')
        return
        
    log.info('Found specprod={}'.format(specprod))

    # optionally trim to a particular tile and/or night
    def _select_tile_night(fastfit, tile=None, night=None):
        if fastfit and (tile or night):
            keep = np.ones(len(fastfit), bool)
            if tile:
                keep *= (fastfit['TILEID'].astype(str) == tile)
            if night:
                keep *= (fastfit['NIGHT'].astype(str) == night)
            fastfit = fastfit[keep]
            log.info('Keeping {} spectra from tile {} on night {}.'.format(len(fastfit), tile, night))
        return fastfit

    fastphot = _select_tile_night(fastphot)
    fastspec = _select_tile_night(fastspec)

    # parse the targetids optional input
    if args.targetids:
        targetids = [int(x) for x in args.targetids.split(',')]
    else:
        targetids = args.targetids

    # Initialize the continuum- and emission-line fitting classes.
    t0 = time.time()
    CFit = ContinuumFit()
    EMFit = EMLineFit()
    log.info('Initializing the classes took: {:.2f} sec'.format(time.time()-t0))

    if fastspec:
        Spec = DESISpectra()
        
        # Get the spectra (if needed).
        Spec.find_specfiles(fastfit=fastfit, specprod=specprod, targetids=targetids,
                            firsttarget=args.firsttarget, ntargets=args.ntargets)
        if len(Spec.specfiles) == 0:
            return
        data = Spec.read_and_unpack(CFit, synthphot=False)
        fastspec = fastspec[np.hstack([np.where(tid == fastspec['TARGETID'])[0] for tid in Spec.zbest['TARGETID']])]
        assert(np.all(fastspec['TARGETID'] == Spec.zbest['TARGETID']))
        
    if fastphot:
        fastphot = fastphot[np.hstack([np.where(tid == fastphot['TARGETID'])[0] for tid in fastspec['TARGETID']])]

    # Build the QA in parallel
    t0 = time.time()
    if fastphot is not None and fastspec is not None:
        qaargs = [(CFit, EMFit, data[igal], fastspec[igal], fastphot[igal], args.outdir, args.suffix)
                  for igal in np.arange(len(fastspec))]
    elif fastphot is None and fastspec is not None:
        qaargs = [(CFit, EMFit, data[igal], fastspec[igal], None, args.outdir, args.suffix)
                  for igal in np.arange(len(fastspec))]
    elif fastphot is not None and fastspec is None:
        qaargs = [(CFit, EMFit, None, None, fastphot[igal], args.outdir, args.suffix)
                  for igal in np.arange(len(fastphot))]
    else:
        pass
        
    if args.mp > 1:
        import multiprocessing
        with multiprocessing.Pool(args.mp) as P:
            P.map(_desiqa_one, qaargs)
    else:
        [desiqa_one(*_qaargs) for _qaargs in qaargs]
    log.info('QA for everything took: {:.2f} sec'.format(time.time()-t0))

if __name__ == '__main__':
    main()
    
